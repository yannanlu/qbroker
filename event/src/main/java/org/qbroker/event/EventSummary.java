package org.qbroker.event;

/* EventSummary.java - an EventMerger to summarize events */

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Date;
import org.qbroker.common.Template;
import org.qbroker.common.TextSubstitution;
import org.qbroker.common.Utils;
import org.qbroker.event.Event;
import org.qbroker.event.EventMerger;

/**
 * EventSummary implements EventMerger and merges all given events into
 * a new event by summarizing the content of them according to the ruleset.
 * The summary is generated by the template and the substitution operations.
 * If Type is set to MessageSummary, it will return a TextEvent as a JMS
 * message instead.
 *<br>
 * @author yannanlu@yahoo.com
 */

public class EventSummary implements EventMerger {
    private String name;
    private String site;
    private String type;
    private String category;
    private String description;
    private Map<String, Object>[] aggregation = null;
    private Map subMap = null;
    private Template summaryTemplate;
    private String summaryHeader = null;
    private String summaryFooter = null;
    private String summaryDefault = "-";
    private int defaultOperation = -1, defaultPriority = -1;
    private String hostname, program, pid;
    private boolean isJMSEvent = false;
    private static java.lang.reflect.Constructor con = null;
    public final static int AGGR_MIN = 0;
    public final static int AGGR_MAX = 1;
    public final static int AGGR_SUM = 2;
    public final static int AGGR_AVG = 3;
    public final static int AGGR_FIRST = 4;
    public final static int AGGR_LAST = 5;
    public final static int AGGR_COUNT = 6;

    @SuppressWarnings("unchecked")
    public EventSummary(Map props) {
        Object o;
        Map h;
        String operation;
        int i, n;

        if ((o = props.get("Name")) == null)
            throw(new IllegalArgumentException("Name is not defined"));
        name = (String) o;
        site = (String) props.get("Site");
        category = (String) props.get("Category");
        if (props.get("Type") != null)
            type = (String) props.get("Type");
        else
            type = "EventSummary";

        if ("MessageSummary".equals(type))
            isJMSEvent = true;
        if ((o = props.get("Description")) != null)
            description = (String) o;
        else
            description = "summarize a group of events into a new event";

        if((o = props.get("SummaryTemplate")) == null || !(o instanceof String))
            throw(new IllegalArgumentException(name +
                ": SummaryTemplate is empty"));
        summaryTemplate = new Template((String) o);

        if ((o = props.get("SummarySubstitution")) != null && o instanceof Map)
            subMap = TextSubstitution.getSubstitutionMap((Map) o);

        if ((o = props.get("SummaryHeader")) != null && o instanceof String)
            summaryHeader = (String) o;

        if ((o = props.get("SummaryFooter")) != null && o instanceof String)
            summaryFooter = (String) o;

        if ((o = props.get("SummaryDefault")) != null && o instanceof String)
            summaryDefault = (String) o;

        if ((o = props.get("Aggregation")) != null || o instanceof List) {
            List list = (List) o;
            n = list.size();

            aggregation = new HashMap[n];
            for (i=0; i<n; i++) {
                o = list.get(i);
                if (o == null || !(o instanceof Map))
                    continue;
                h = (Map) o;
                aggregation[i] = Utils.cloneProperties(h);
                o = h.get("Operation");
                operation = (String) o;
                if ("min".equals(operation))
                    aggregation[i].put("Operation", String.valueOf(AGGR_MIN));
                else if ("max".equals(operation))
                    aggregation[i].put("Operation", String.valueOf(AGGR_MAX));
                else if ("sum".equals(operation))
                    aggregation[i].put("Operation", String.valueOf(AGGR_SUM));
                else if ("avg".equals(operation))
                    aggregation[i].put("Operation", String.valueOf(AGGR_AVG));
                else if ("first".equals(operation))
                    aggregation[i].put("Operation", String.valueOf(AGGR_FIRST));
                else if ("last".equals(operation))
                    aggregation[i].put("Operation", String.valueOf(AGGR_LAST));
                else if ("count".equals(operation))
                    aggregation[i].put("Operation", String.valueOf(AGGR_COUNT));
                else
                    aggregation[i].put("Operation", String.valueOf(AGGR_LAST));

                if ("priority".equals((String)aggregation[i].get("FieldName"))){
                    o = aggregation[i].get("DefaultValue");
                    defaultPriority = Integer.parseInt((String) o);
                    o = aggregation[i].get("Operation");
                    defaultOperation = Integer.parseInt((String) o);
                }
            }
        }
        else {
            aggregation = null;
        }
        if (defaultOperation < 0)
            defaultOperation = AGGR_MIN;
        if (defaultPriority < 0)
            defaultPriority = Event.INFO;
        hostname = Event.getHostName();
        program = Event.getProgramName();
        pid = String.valueOf(Event.getPID());
    }

    public Event merge(long currentTime, Event[] eventGroup) {
        if (eventGroup == null)
            return new Event(Event.INFO, name + ": eventGroup is null");

        String summary = summarize(currentTime, eventGroup);
        int n = eventGroup.length;
        int priority = getPriority(defaultOperation, eventGroup);
        String text = name + " matches " + n + " events";

        Event event;
        if (!isJMSEvent)
            event = new Event(priority, text);
        else try {
            if (con == null)
                initTextEventConstructor();
            event = (Event) con.newInstance(new Object[]{text});
            event.setPriority(priority);
            event.removeAttribute("priority");
        }
        catch (Throwable t) {
            throw(new RuntimeException(name +
                " failed to create a TextEvent: " + Utils.traceStack(t)));
        }
        event.timestamp = currentTime;
        event.setAttribute("name", name);
        event.setAttribute("site", site);
        event.setAttribute("category", category);
        event.setAttribute("type", type);
        event.setAttribute("description", description);
        event.setAttribute("date", Event.dateFormat(new Date(currentTime)));
        event.setAttribute("status", "Normal");
        event.setAttribute("eventCount", String.valueOf(n));
        event.setAttribute("summary", summary);

        if (aggregation != null) // aggregation
            aggregate(event, eventGroup);

        if (event.attributeExists("hostname"))
            event.setAttribute("originalHost", event.getAttribute("hostname"));
        event.setAttribute("program", program);
        event.setAttribute("hostname", hostname);
        event.setAttribute("pid", pid);

        return event;
    }

    private String summarize(long currentTime, Event[] eventGroup) {
        StringBuffer strBuf = new StringBuffer();
        int i, j, n;
        String[] fields;
        String value, text;
        TextSubstitution[] sub;
        Object o;
        HashMap attr;
        if (eventGroup == null || (n = eventGroup.length) == 0)
            return null;

        i = summaryTemplate.size();
        fields = summaryTemplate.keySet().toArray(new String[i]);
        if (summaryHeader != null)
            strBuf.append(summaryHeader);
        if (subMap == null || subMap.size() <= 0) {
            for (i=0; i<n; i++) {
                attr = eventGroup[i].attribute;
                text = summaryTemplate.copyText();
                for (j=0; j<fields.length; j++) {
                    o = attr.get(fields[j]);
                    if (o != null && o instanceof String)
                        value = (String) o;
                    else if (isJMSEvent && "text".equals(fields[j])) {
                        o = eventGroup[i].body;
                        if (o != null && o instanceof String)
                            value = (String) o;
                        else
                            value = summaryDefault;
                    }
                    else
                        value = summaryDefault;
                    text = summaryTemplate.substitute(fields[j], value, text);
                }
                strBuf.append(text);
            }
        }
        else { // with substitutions
            for (i=0; i<n; i++) {
                attr = eventGroup[i].attribute;
                text = summaryTemplate.copyText();
                for (j=0; j<fields.length; j++) {
                    o = attr.get(fields[j]);
                    if (o != null && o instanceof String)
                        value = (String) o;
                    else if (isJMSEvent && "text".equals(fields[j])) {
                        o = eventGroup[i].body;
                        if (o != null && o instanceof String)
                            value = (String) o;
                        else
                            value = null;
                    }
                    else
                        value = null;
                    if (value == null)
                        value = summaryDefault;
                    else if ((o = subMap.get(fields[j])) != null) {
                        sub = (TextSubstitution[]) o;
                        for (int k=0; k<sub.length; k++)
                            value = sub[k].substitute(value);
                    }
                    text = summaryTemplate.substitute(fields[j], value, text);
                }
                strBuf.append(text);
            }
        }
        if (summaryFooter != null)
            strBuf.append(summaryFooter);

        return strBuf.toString();
    }

    private void aggregate(Event event, Event[] eventGroup) {
        int i, j, n, m, count, operation;
        HashMap attr;
        Map h;
        Object o;
        String field;

        if (eventGroup == null || (n = eventGroup.length) <= 0)
            return;

        for (i=0; i<aggregation.length; i++) {
            h = aggregation[i];
            field = (String) h.get("FieldName");
            if (field == null || field.length() <= 0)
                continue;
            if ("priority".equals(field))
                continue;
            operation = Integer.parseInt((String) h.get("Operation"));
            switch (operation) {
              case AGGR_SUM:
                count = 0;
                m = 0;
                for (j=0; j<n; j++) {
                    attr = eventGroup[j].attribute;
                    if ((o = attr.get(field)) == null)
                        continue;
                    count += Integer.parseInt((String) o);
                    m ++;
                }
                if (m > 0)
                    event.setAttribute(field, String.valueOf(count));
                else
                    event.setAttribute(field, (String) h.get("DefaultValue"));
                break;
              case AGGR_AVG:
                count = 0;
                m = 0;
                for (j=0; j<n; j++) {
                    attr = eventGroup[j].attribute;
                    if ((o = attr.get(field)) == null)
                        continue;
                    count += Integer.parseInt((String) o);
                    m ++;
                }
                if (m > 0) {
                    count = (int) (100.0 * count) / m;
                    event.setAttribute(field, String.valueOf(0.01 * count));
                }
                else
                    event.setAttribute(field, (String) h.get("DefaultValue"));
                break;
              case AGGR_MAX:
                count = 0;
                m = 0;
                for (j=0; j<n; j++) {
                    attr = eventGroup[j].attribute;
                    if ((o = attr.get(field)) == null)
                        continue;
                    if (m == 0)
                        count = Integer.parseInt((String) o);
                    else if (Integer.parseInt((String) o) > count)
                        count = Integer.parseInt((String) o);
                    m ++;
                }
                if (m > 0)
                    event.setAttribute(field, String.valueOf(count));
                else
                    event.setAttribute(field, (String) h.get("DefaultValue"));
                break;
              case AGGR_MIN:
                count = 0;
                m = 0;
                for (j=0; j<n; j++) {
                    attr = eventGroup[j].attribute;
                    if ((o = attr.get(field)) == null)
                        continue;
                    if (m == 0)
                        count = Integer.parseInt((String) o);
                    else if (Integer.parseInt((String) o) < count)
                        count = Integer.parseInt((String) o);
                    m ++;
                }
                if (m > 0)
                    event.setAttribute(field, String.valueOf(count));
                else
                    event.setAttribute(field, (String) h.get("DefaultValue"));
                break;
              case AGGR_FIRST:
                m = 0;
                for (j=0; j<n; j++) {
                    attr = eventGroup[j].attribute;
                    if ((o = attr.get(field)) == null)
                        continue;
                    event.setAttribute(field, (String) o);
                    m ++;
                    break;
                }
                if (m == 0)
                    event.setAttribute(field, (String) h.get("DefaultValue"));
                break;
              case AGGR_LAST:
                m = 0;
                for (j=n-1; j>=0; j--) {
                    attr = eventGroup[j].attribute;
                    if ((o = attr.get(field)) == null)
                        continue;
                    event.setAttribute(field, (String) o);
                    m ++;
                    break;
                }
                if (m == 0)
                    event.setAttribute(field, (String) h.get("DefaultValue"));
                break;
              default:
                break;
            }
        }
    }

    private int getPriority(int operation, Event[] eventGroup) {
        int i, n, m = 0, p, priority = defaultPriority;
        if (eventGroup == null || (n = eventGroup.length) <= 0)
            return defaultPriority;

        switch (operation) {
          case AGGR_MAX:
            for (i=0; i<n; i++) {
                p = eventGroup[i].getPriority();
                if (m == 0)
                    priority = p;
                else if (p > priority)
                    priority = p;
                m ++;
            }
            if (m == 0)
                priority = defaultPriority;
            break;
          case AGGR_MIN:
            for (i=0; i<n; i++) {
                p = eventGroup[i].getPriority();
                if (m == 0)
                    priority = p;
                else if (p < priority)
                    priority = p;
                m ++;
            }
            if (m == 0)
                priority = defaultPriority;
            break;
          case AGGR_FIRST:
            if (n > 0)
                p = eventGroup[0].getPriority();
            else
                priority = defaultPriority;
            break;
          case AGGR_LAST:
            if (n > 0)
                p = eventGroup[n-1].getPriority();
            else
                priority = defaultPriority;
            break;
          default:
            priority = defaultPriority;
            break;
        }
        return priority;
    }

    public String getName() {
        return name;
    }

    public void close() {
        con = null;
        if (subMap != null) {
            subMap.clear();
            subMap = null;
        }
        if (summaryTemplate != null) {
            summaryTemplate.clear();
            summaryTemplate = null;
        }
        if (aggregation != null) {
            for (Map map : aggregation)
                if (map != null) map.clear();
            for (int i=0; i<aggregation.length; i++)
                aggregation[i] = null;
            aggregation = null;
        }
    }

    protected void finalize() {
        close();
    }

    private synchronized static void initTextEventConstructor() {
        if (con != null)
            return;
        try {
            Class<?> cls = Class.forName("org.qbroker.jms.TextEvent");
            con = cls.getConstructor(new Class[]{
                Class.forName("java.lang.String")});
        }
        catch(Exception e) {
            throw(new RuntimeException(Utils.traceStack(e)));
        }
    }
}
