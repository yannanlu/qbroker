package org.qbroker.node;

/* EventMonitor.java - a MessageNode monitoring and tracking events */

import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;
import java.util.Date;
import java.lang.reflect.InvocationTargetException;
import javax.jms.Message;
import javax.jms.TextMessage;
import javax.jms.JMSException;
import org.qbroker.common.XQueue;
import org.qbroker.common.Browser;
import org.qbroker.common.AssetList;
import org.qbroker.common.TimeWindows;
import org.qbroker.common.Template;
import org.qbroker.common.TextSubstitution;
import org.qbroker.common.QuickCache;
import org.qbroker.common.CollectibleCells;
import org.qbroker.monitor.ConfigList;
import org.qbroker.jms.MessageFilter;
import org.qbroker.jms.MessageUtils;
import org.qbroker.jms.JMSEvent;
import org.qbroker.jms.TextEvent;
import org.qbroker.node.Node;
import org.qbroker.node.NodeUtils;
import org.qbroker.event.EventEscalation;
import org.qbroker.event.EventSelector;
import org.qbroker.event.EventUtils;
import org.qbroker.event.Event;

/**
 * EventMonitor monitors incoming JMS events and keeps tracking their state
 * according to the rulesets and the value of the aggregated attribute.
 * In case that the state changes up to a certain point, EventMonitor will
 * generate a new JMS event as the escalation.  All escalation events will
 * be routed to the outlink of done. For all the incoming events, EventMonitor
 * routes them into three outlinks: bypass for all the processed incoming
 * events, nohit for those events do not belong to any rulesets, failure for
 * the incoming events failed in the process. However, the outlink of done
 * can be shared with other outlinks.
 *<br/><br/>
 * EventMonitor contains a number of predefined rulesets.  These rulesets
 * categorize incoming events into non-overlapping groups.  Therefore, each
 * ruleset defines a unique event group.  It contains the name of the rule,
 * and an EventSelector to select events for the group.  If PreferredOutLink
 * is defined in the ruleset, it is treated as a bypass ruleset. Otherwise,
 * it will be treated as an escalation ruleset that may generate extra messages.
 * For those escalation messages, they will get formatted if the post formatter
 * is defined in their rulesets.
 *<br/><br/>
 * For each incomiong event, EventMonitor will match it against every
 * EventSelectors to single out a ruleset. There are two cases for escalation
 * rulesets. If ClassName is defined in a ruleset, it will be used to
 * instantiate an instance of EventEscalation. Otherwise, it is the timeout
 * escalation ruleset in which EventMonitor expects certain events showing up
 * frequently. If a ruleset of EventEscalation is selected, EventMonitor will
 * invoke its public method of escalate() to evalaute the event. The instance
 * of EventEscalation is supposed to maintain the state for the event group.
 * In case that a state change is up to certain point, an escalation event will
 * be generated by its method of escalate(). This event will contain details
 * of the state change. It will be delivered according to the predefined
 * EscalationOrder with the value of either "first", "last" or "none" for no
 * order preference. In case of "first" or "last", the ruleset also allows
 * ActionDelay defined in millisec. In case of the ruleset of "last", it
 * specifies how long the escalation gets delayed. For the ruleset of "first",
 * the delay happens after the escalation. EscalationMask controls the display
 * mask on escalation messages.
 *<br/><br/>
 * In case of a ruleset for timeout escalations, KeyTemplate is required to be
 * defined so that EventMonitor is able cache the properties of the incoming
 * event with the unique key for a new state or update the timestamp of
 * an existing state with the incoming event. The ruleset expects certain
 * events kept coming to keep it up to date. If the expected event has not
 * shown up within a given interval, an escalation event will be generated as
 * the escalation with the priority set to EscalationPriority. A list of
 * attribute names is specified in CopiedProperty. Those attributes cached from
 * the first incoming event will be copied to the escalation event. The tracking
 * session for an existing state can be terminated or reset by an event whose
 * priority is same as the predefined ResetPriority of the ruleset. The timeout
 * escalation ruleset is good to track those alerts fired only once.
 *<br/><br/>
 * EventMonitor always creates one extra ruleset, nohit. The ruleset of nohit
 * is for those events not hitting any patterns. Its RULE_PEND field is used to
 * store the total number of cached states for all timeout rulesets.
 * Please remember that there is no one-to-one relationship between the
 * candidate events and the esacaltion events. The total number of escalation
 * events for a ruleset is stored into its RULE_PEND field.
 *<br/><br/>
 * You are free to choose any names for the four fixed outlinks.  But
 * EventMonitor always assumes the first outlink for done, the second for
 * bypass, the third for failure and the last for nohit.  Any two or more
 * outlinks can share the same outlink name. It means these outlinks are
 * sharing the same output channel.
 *<br/>
 * @author yannanlu@yahoo.com
 */

public class EventMonitor extends Node {
    private long heartbeat = 60000;
    private int[] outLinkMap;

    private final static int RESULT_OUT = 0;
    private final static int BYPASS_OUT = 1;
    private final static int FAILURE_OUT = 2;
    private final static int NOHIT_OUT = 3;

    public EventMonitor(Map props) {
        super(props);
        Object o;
        List list;
        String key;
        Browser browser;
        Map<String, Object> rule;
        Map ph;
        long[] outInfo, ruleInfo;
        long tm;
        int i, j, n, ruleSize = 512;
        StringBuffer strBuf = new StringBuffer();

        if ((o = props.get("Operation")) != null)
            operation = (String) o;
        else
            operation = "escalate";
        if ((o = props.get("MaxNumberRule")) != null)
            ruleSize = Integer.parseInt((String) o);
        if (ruleSize <= 0)
            ruleSize = 512;

        if ((o = props.get("Heartbeat")) != null) {
            heartbeat = 1000 * Integer.parseInt((String) o);
            if (heartbeat < 0)
                heartbeat = 60000;
        }

        if ((o = props.get("OutLink")) == null || !(o instanceof List))
            throw(new IllegalArgumentException(name +
                ": OutLink is not well defined"));

        list = (List) o;
        n = list.size();

        tm = System.currentTimeMillis();

        int[] overlap = new int[]{BYPASS_OUT, FAILURE_OUT, NOHIT_OUT};
        assetList = NodeUtils.initFixedOutLinks(tm, capacity, n, overlap,
            name, list);
        outLinkMap = new int[]{RESULT_OUT, BYPASS_OUT, FAILURE_OUT, NOHIT_OUT};
        outLinkMap[BYPASS_OUT] = overlap[0];
        outLinkMap[FAILURE_OUT] = overlap[1];
        outLinkMap[NOHIT_OUT] = overlap[2];

        if (assetList == null)
            throw(new IllegalArgumentException(name +
                ": failed to init OutLinks"));

        browser = assetList.browser();
        while ((i = browser.next()) >= 0) {
            outInfo = assetList.getMetaData(i);
            if (outInfo[OUT_OFFSET] < 0 || outInfo[OUT_LENGTH] < 0 ||
                (outInfo[OUT_LENGTH]==0 && outInfo[OUT_OFFSET]!=0) ||
                outInfo[OUT_LENGTH] + outInfo[OUT_OFFSET] >
                outInfo[OUT_CAPACITY])
                throw(new IllegalArgumentException(name +
                    ": OutLink Partition is not well defined for " +
                    assetList.getKey(i)));
            if ((debug & DEBUG_INIT) > 0)
                strBuf.append("\n\t" + assetList.getKey(i) + ": " + i + " " +
                    outInfo[OUT_CAPACITY] + " " + outInfo[OUT_OFFSET] +
                    "," + outInfo[OUT_LENGTH]);
        }

        if ((debug & DEBUG_INIT) > 0) {
            new Event(Event.DEBUG, name + " LinkName: OID Capacity Partition " +
                " - " + linkName + " " + capacity + strBuf.toString()).send();
            strBuf = new StringBuffer();
        }

        i = outLinkMap[NOHIT_OUT];
        i = (i >= outLinkMap[FAILURE_OUT]) ? i : outLinkMap[FAILURE_OUT];
        i = (i >= outLinkMap[BYPASS_OUT]) ? i : outLinkMap[BYPASS_OUT];
        if (++i > assetList.size())
            throw(new IllegalArgumentException(name+": missing some OutLinks"));

        cfgList = new AssetList(name, 64);
        msgList = new AssetList(name, capacity);
        ruleList = new AssetList(name, ruleSize);
        cells = new CollectibleCells(name, capacity);

        if ((o = props.get("Ruleset")) != null && o instanceof List)
            list = (List) o;
        else
            list = new ArrayList();
        n = list.size();

        try { // init rulesets
            String str;
            ConfigList cfg;
            int k, m;
            // for nohit
            key = "nohit";
            ruleInfo = new long[RULE_TIME + 1];
            for (i=0; i<=RULE_TIME; i++)
                ruleInfo[i] = 0;
            ruleInfo[RULE_STATUS] = NODE_RUNNING;
            ruleInfo[RULE_DMASK] = displayMask;
            ruleInfo[RULE_TIME] = tm;
            ruleInfo[RULE_OID] = outLinkMap[NOHIT_OUT];
            ruleInfo[RULE_PID] = TYPE_BYPASS;
            rule = new HashMap<String, Object>();
            rule.put("Name", key);
            rule.put("PropertyName", displayPropertyName);
            ruleList.add(key, ruleInfo, rule);
            outInfo = assetList.getMetaData(outLinkMap[NOHIT_OUT]);
            outInfo[OUT_NRULE] ++;
            outInfo[OUT_ORULE] ++;

            for (i=0; i<n; i++) { // for defined rules
                o = list.get(i);
                if (o instanceof String) {
                    o = props.get((String) o);
                    if (o == null || !(o instanceof Map)) {
                        new Event(Event.ERR, name + ": ruleset " + i + ", " +
                            (String)list.get(i)+", is not well defined").send();
                        continue;
                    }
                }
                ph = (Map) o;
                if((o = ph.get("RuleType")) == null || !(o instanceof String) ||
                    !"ConfigList".equals((String) o)) {
                    ruleInfo = new long[RULE_TIME+1];
                    rule = initRuleset(tm, ph, ruleInfo);
                    if(rule != null && (key=(String) rule.get("Name")) != null){
                        if(ruleList.add(key, ruleInfo, rule) < 0)//failed to add
                            new Event(Event.ERR, name + ": ruleset " + i + ", "+
                                key + ", failed to be added").send();
                    }
                    else
                        new Event(Event.ERR, name + ": ruleset " + i +
                            " failed to be initialized").send();
                    continue;
                }
                try { // for external rules via ConfigList
                    cfg = new ConfigList(ph);
                }
                catch (Exception ex) {
                    new Event(Event.ERR, name + ": ConfigList " + i +
                        " failed to be initialized").send();
                    continue;
                }
                key = cfg.getName();
                cfg.setDataField(name);
                cfg.loadList();
                k = cfg.getSize();
                m = cfgList.add(key, new long[]{k, 0}, cfg);
                if (m < 0) {
                    new Event(Event.ERR, name + ": ConfigList " + key +
                        " failed to be added to the list").send();
                    cfg.close();
                    continue;
                }
                for (j=0; j<k; j++) { // init all external rulesets
                    str = cfg.getItem(j);
                    ph = cfg.getProps(str);
                    key = cfg.getKey(j);
                    ruleInfo = new long[RULE_TIME+1];
                    try {
                        rule = initRuleset(tm, ph, ruleInfo);
                    }
                    catch (Exception ex) {
                        new Event(Event.ERR, name + ": ConfigList " +
                            cfg.getName()+" failed to init external rule "+key+
                            " at " + j + ": " + Event.traceStack(ex)).send();
                        continue;
                    }
                    if (rule != null && rule.size() > 0) {
                        if(ruleList.add(key, ruleInfo, rule) < 0)//failed to add
                            new Event(Event.ERR, name + ": ConfigList " +
                                cfg.getName()+ " failed to add external rule " +
                                key + " at " + j).send();
                    }
                    else
                        new Event(Event.ERR, name + ": ConfigList " +
                            cfg.getName()+ " failed to init external rule "+
                            key + " at " + j).send();
                }
            }
        }
        catch (Exception e) {
            throw(new IllegalArgumentException(name + ": failed to init rule "+
                i + ": " + Event.traceStack(e)));
        }

        if ((debug & DEBUG_INIT) > 0) {
            browser = ruleList.browser();
            while ((i = browser.next()) >= 0) {
                ruleInfo = ruleList.getMetaData(i);
                strBuf.append("\n\t" + ruleList.getKey(i) + ": " + i + " " +
                    ruleInfo[RULE_PID] + " " + ruleInfo[RULE_EXTRA] + " " +
                    ruleInfo[RULE_TTL]/1000 + " " + ruleInfo[RULE_DMASK] + " "+
                    ruleInfo[RULE_OPTION] + " " + ruleInfo[RULE_GID] + " - " +
                    assetList.getKey((int) ruleInfo[RULE_OID]));
            }
            new Event(Event.DEBUG, name+
                " RuleName: RID PID EXTRA TTL DMASK OPTION GID - OutName" +
                strBuf.toString()).send();
        }
    }

    /**
     * It initializes a new ruleset with the ruleInfo and returns the rule upon
     * success.  Otherwise, it throws an exception or returns null.
     */
    protected Map<String, Object> initRuleset(long tm, Map ph, long[] ruleInfo){
        Object o;
        Map<String, Object> rule;
        List list;
        String key, str, ruleName, preferredOutName;
        long[] outInfo;
        int i, k, n, id;

        if (ph == null || ph.size() <= 0)
            throw(new IllegalArgumentException("Empty property for a rule"));
        if (ruleInfo == null || ruleInfo.length <= RULE_TIME)
            throw(new IllegalArgumentException("ruleInfo is not well defined"));
        ruleName = (String) ph.get("Name");
        if (ruleName == null || ruleName.length() == 0)
            throw(new IllegalArgumentException("ruleName is not defined"));
        rule = new HashMap<String, Object>();
        rule.put("Name", ruleName);
        preferredOutName = (String) ph.get("PreferredOutLink");
        if(preferredOutName !=null && !assetList.containsKey(preferredOutName)){
            preferredOutName = assetList.getKey(outLinkMap[NOHIT_OUT]);
            new Event(Event.WARNING, name + ": OutLink for " +
                ruleName + " not well defined, use the default: "+
                preferredOutName).send();
        }

        for (i=0; i<=RULE_TIME; i++)
            ruleInfo[i] = 0;

        ruleInfo[RULE_STATUS] = NODE_RUNNING;
        ruleInfo[RULE_TIME] = tm;

        if ((o = ph.get("DisplayMask")) != null && o instanceof String)
            ruleInfo[RULE_DMASK] = Integer.parseInt((String) o);
        else
            ruleInfo[RULE_DMASK] = displayMask;

        // store escalation mask into RULE_OPTION
        if ((o = ph.get("EscalationMask")) != null)
            ruleInfo[RULE_OPTION] = Integer.parseInt((String) o);
        else
            ruleInfo[RULE_OPTION] = ruleInfo[RULE_DMASK];

        // store ttl or sessionTimeout into RULE_TTL
        if ((o = ph.get("TimeToLive")) != null)
            ruleInfo[RULE_TTL] = 1000 * Integer.parseInt((String) o);
        else if ((o = ph.get("SessionTimeout")) != null)
            ruleInfo[RULE_TTL] = 1000 * Integer.parseInt((String) o);

        rule.put("Filter", new EventSelector(ph));

        if (preferredOutName != null) { // for bypass
            ruleInfo[RULE_OID] = assetList.getID(preferredOutName);
            ruleInfo[RULE_PID] = TYPE_BYPASS;
        }
        else if ((o = ph.get("ClassName")) != null && o instanceof String) {
            // for EventEscalation
            java.lang.reflect.Constructor con;
            EventEscalation escalator = null;
            TimeWindows tw = null;
            String className = (String) o;
                
            try {
                Class<?> cls = Class.forName(className);
                con = cls.getConstructor(new Class[]{Map.class});
                escalator = (EventEscalation) con.newInstance(new Object[]{ph});
                if ((o = ph.get("ActiveTime")) != null)
                    tw = new TimeWindows((Map) o);
            }
            catch (InvocationTargetException e) {
                Throwable ex = e.getTargetException();
                new Event(Event.ERR, name + ": failed to init " +
                    ruleName + ": " + Event.traceStack(ex));
                return null;
            }
            catch (Exception e) {
                new Event(Event.ERR, name + ": failed to init " +
                    ruleName + ": " + Event.traceStack(e));
                return null;
            }

            rule.put("Escalation", escalator);
            if (tw != null)
                rule.put("TimeWindows", tw);

            // init post formatter for escalation events only
            if ((o = ph.get("FormatterArgument")) != null && o instanceof List){
                Map<String, Object> hmap = new HashMap<String, Object>();
                hmap.put("Name", ruleName);
                hmap.put("FormatterArgument", o);
                hmap.put("ResetOption", "0");
                rule.put("Formatter", new MessageFilter(hmap));
                hmap.clear();
            }

            // escalation order stored in RULE_EXTRA
            ruleInfo[RULE_EXTRA] = escalator.getEscalationOrder();

            // action delay in ms stored in GID
            if ((o = ph.get("ActionDelay")) != null)
                ruleInfo[RULE_GID] = Long.parseLong((String) o);

            ruleInfo[RULE_OID] = outLinkMap[BYPASS_OUT];
            ruleInfo[RULE_PID] = TYPE_ACTION;
        }
        else if((o = ph.get("KeyTemplate")) == null || !(o instanceof String)){
            ruleInfo[RULE_OID] = outLinkMap[BYPASS_OUT];
            ruleInfo[RULE_PID] = TYPE_BYPASS;
            new Event(Event.WARNING, name + ": PreferredOutLink is not well " +
                "defined. Instead, the default will be used for " +
                ruleName).send();
        }
        else { // default rule for timeout
            rule.put("KeyTemplate", new Template((String) o));
            if ((o = ph.get("KeySubstitution")) != null && o instanceof String)
                rule.put("KeySubstitution", new TextSubstitution((String) o));

            // init post formatter for escalation events only
            if ((o = ph.get("FormatterArgument")) != null && o instanceof List){
                Map<String, Object> hmap = new HashMap<String, Object>();
                hmap.put("Name", ruleName);
                hmap.put("FormatterArgument", o);
                hmap.put("ResetOption", "0");
                rule.put("Formatter", new MessageFilter(hmap));
                hmap.clear();
            }

            // EscalationPriority stored in EXTRA
            if ((o = ph.get("EscalationPriority")) != null)
                ruleInfo[RULE_EXTRA] = Event.getPriorityByName((String) o);
            if (ruleInfo[RULE_EXTRA] < 0)
                ruleInfo[RULE_EXTRA] = Event.getPriorityByName("INFO");

            // ResetPriority stored in GID
            if ((o = ph.get("ResetPriority")) != null)
                ruleInfo[RULE_GID] = Event.getPriorityByName((String) o);
            else
                ruleInfo[RULE_GID] = -1;

            if ((o = ph.get("CopiedProperty")) != null && o instanceof List) {
                List<String> pl = new ArrayList<String>();
                for (Object ky : (List) o) {
                    if (!(ky instanceof String))
                        continue;
                    key = (String) ky;
                    if (key.length() > 0)
                        pl.add(key);
                }
                rule.put("CopiedProperty", pl.toArray(new String[pl.size()]));
            }
            else
                rule.put("CopiedProperty", new String[0]);

            rule.put("Cache",
                new QuickCache(ruleName, QuickCache.META_DEFAULT, 0, 0));
            ruleInfo[RULE_OID] = outLinkMap[RESULT_OUT];
            ruleInfo[RULE_PID] = TYPE_CACHE;
        }
        outInfo = assetList.getMetaData((int) ruleInfo[RULE_OID]);
        outInfo[OUT_NRULE] ++;
        outInfo[OUT_ORULE] ++;

        // for StringProperty
        if ((o = ph.get("StringProperty")) != null && o instanceof Map) {
            Iterator iter = ((Map) o).keySet().iterator();
            k = ((Map) o).size();
            String[] pn = new String[k];
            k = 0;
            while (iter.hasNext()) {
                key = (String) iter.next();
                if ((pn[k] = MessageUtils.getPropertyID(key)) == null)
                    pn[k] = key;
                k ++;
            }
            rule.put("PropertyName", pn);
        }
        else if (o == null)
            rule.put("PropertyName", displayPropertyName);

        return rule;
    }

    /**
     * picks up a message from input queue and evaluates its content to
     * decide which output queue to propagate
     */
    public void propagate(XQueue in, XQueue[] out) throws JMSException {
        Message inMessage;
        TextEvent msg = null;
        Event event = null;
        String msgStr = null, ruleName = null;
        Object o;
        Object[] asset;
        String[] propertyName = null;
        EventSelector[] filter = null;
        EventEscalation escalator = null;
        TimeWindows tw = null;
        Template temp = null;
        TextSubstitution tsub = null;
        QuickCache cache = null;
        Map rule = null;
        Browser browser;
        int[] ruleMap;
        long[] ri, outInfo, ruleInfo = null;
        long currentTime, previousTime, wt, count = 0;
        int mask, ii, sz, dspBody;
        int i = 0, m, n, previousRid;
        int rid = -1; // the rule id
        int cid = -1; // the cell id of the message in input queue
        int oid = 0; // the id of the output queue
        boolean isJMSEvent = false;
        byte[] buffer = new byte[bufferSize];

        i = in.getCapacity();
        if (capacity != i) { // assume it only occurs at startup
            new Event(Event.WARNING, name + ": " + in.getName() +
                " has the different capacity of " + i + " from " +
                capacity).send();
            capacity = i;
            msgList.clear();
            msgList = new AssetList(name, capacity);
            cells.clear();
            cells = new CollectibleCells(name, capacity);
        }

        // initialize patterns
        m = ruleList.size();
        filter = new EventSelector[m];
        browser = ruleList.browser();
        ruleMap = new int[m];
        ri = ruleList.getMetaData(0);
        i = 0;
        while ((rid = browser.next()) >= 0) {
            rule = (Map) ruleList.get(rid);
            filter[i] = (EventSelector) rule.get("Filter");
            ruleMap[i++] = rid;
        }
        dspBody = MessageUtils.SHOW_BODY + MessageUtils.SHOW_SIZE;

        // update assetList
        n = out.length;
        for (i=0; i<n; i++) {
            asset = (Object[]) assetList.get(i);
            asset[ASSET_XQ] = out[i];
            outInfo = assetList.getMetaData(i);
            if (outInfo[OUT_CAPACITY] != out[i].getCapacity())
                outInfo[OUT_CAPACITY] = out[i].getCapacity();
        }

        previousTime = 0L;
        previousRid = -1;
        ii = 0;
        wt = 5L;
        sz = msgList.size();
        while (((mask = in.getGlobalMask()) & XQueue.KEEP_RUNNING) > 0) {
            if ((mask & XQueue.STANDBY) > 0) // standby temporarily
                break;
            if ((cid = in.getNextCell(wt)) < 0) {
                if (++ii >= 10) {
                    feedback(in, -1L);
                    sz = msgList.size();
                    if (sz <= 0)
                        wt = waitTime;
                    ii = 0;
                }
                else {
                    if (sz > 0)
                        feedback(in, -1L);
                    continue;
                }
            }
            currentTime = System.currentTimeMillis();
            if (currentTime - previousTime >= heartbeat) {
                if(update(currentTime, in, out[0], 0, buffer)>0)//check timeouts
                    currentTime = System.currentTimeMillis();
                previousTime = currentTime;
            }
            if (cid < 0)
                continue;

            wt = 5L;
            if ((inMessage = (Message) in.browse(cid)) == null) {
                in.remove(cid);
                new Event(Event.WARNING, name + ": " + Event.traceStack(
                   new JMSException("null msg from " + in.getName()))).send();
                continue;
            }

            currentTime = System.currentTimeMillis();
            event = null;
            if (inMessage instanceof JMSEvent) {
                event = (Event) inMessage;
                isJMSEvent = true;
            }
            else try { // copy the message into event
                isJMSEvent = false;
                event = (Event) MessageUtils.duplicate(inMessage, buffer);
            }
            catch (JMSException e) {
                new Event(Event.ERR, name + " failed to copy msg: " +
                    Event.traceStack(e)).send();
            }
            catch (Exception e) {
                new Event(Event.ERR, name + " failed to copy msg: " +
                    Event.traceStack(e)).send();
            }

            i = NOHIT_OUT;
            if (event == null) { // for failures
                i = FAILURE_OUT;
            }
            else if (event instanceof TextEvent) { // for TextEvent
                if (((TextEvent) event).getLogMode() != Event.LOG_JMS) try {
                    // not from toEvent, so set attribute of "text"
                    event.setPriority(event.getPriority());
                    event.setAttribute("text", ((TextEvent) event).getText());
                    ((TextEvent) event).setLogMode(Event.LOG_JMS);
                }
                catch (Exception e) {
                    new Event(Event.ERR, name + " failed to reset event: " +
                        Event.traceStack(e)).send();
                    i = FAILURE_OUT;
                }
            }

            rid = 0;
            if (i != FAILURE_OUT) { // evaluate the event with all rulesets
                int j;
                for (j=1; j<m; j++) {
                    if (filter[j].evaluate(currentTime, event))
                        break;
                }
                rid = ruleMap[j%m];
            }

            if (rid != previousRid) {
                ruleName = ruleList.getKey(rid);
                ruleInfo = ruleList.getMetaData(rid);
                rule = (Map) ruleList.get(rid);
                propertyName = (String[]) rule.get("PropertyName");
                if (ruleInfo[RULE_PID] == TYPE_ACTION) {
                    escalator = (EventEscalation) rule.get("Escalation");
                    tw = (TimeWindows) rule.get("TimeWindow");
                }
                else if (ruleInfo[RULE_PID] == TYPE_CACHE) {
                    cache = (QuickCache) rule.get("Cache");
                    temp = (Template) rule.get("KeyTemplate");
                    tsub = (TextSubstitution) rule.get("KeySubstitution");
                }
                previousRid = rid;
            }

            if (rid == 0) { // nohit or failure
                oid = outLinkMap[i];
            }
            else if (TYPE_NONE == ruleInfo[RULE_PID]) { // bypass
                oid = (int) ruleInfo[RULE_OID];
                i = -1;
            }
            else if (TYPE_CACHE == ruleInfo[RULE_PID]) { // default monitor
                String key;
                int ttl = (int) ruleInfo[RULE_TTL];
                if (!isJMSEvent)
                    key = EventUtils.format(event, temp);
                else try {
                    key = MessageUtils.format((JMSEvent) event, buffer, temp);
                }
                catch (Exception e) {
                    new Event(Event.ERR, name + " " + ruleName +
                        " failed to format cache key: " + e.toString()).send(); 
                    key = null;
                }
                if (tsub != null && key != null)
                    key = tsub.substitute(key);

                int p = event.getPriority();
                if (p == (int) ruleInfo[RULE_GID]) { // reset the state
                    if (cache.containsKey(key)) {
                        int[] meta = cache.getMetaData(key);
                        if (meta != null && meta.length > 0) {
                            meta[0] = 0;
                            i = 0;
                        }
                        else
                            i = -1;
                        if (i == 0)
                            ri[RULE_PEND] --;
                        if (!cache.isExpired(key, currentTime))
                            cache.expire(key, currentTime);
                        if ((debug & DEBUG_UPDT) > 0)
                            new Event(Event.DEBUG, name + " " + ruleName +
                                " reset: " + key + " with " + p +
                                ": " + i).send(); 
                    }
                }
                else if (!cache.containsKey(key) || // first event
                    cache.isExpired(key, currentTime)) { // expired
                    Map<String, String> map = new HashMap<String, String>();
                    String[] pn = (String[]) rule.get("CopiedProperty");
                    if (pn.length > 0) {
                        for (String ky : pn)
                            map.put(ky, event.getAttribute(ky));
                    }
                    else { // copy all attributes over
                        for (String str : event.getAttributeNames()) {
                           if (str == null || str.length() <= 0 ||
                               "text".equals(str))
                               continue;
                           map.put(str, event.getAttribute(str));
                        }
                    }
                    i = cache.insert(key, currentTime, ttl, new int[]{1}, map,
                        currentTime);
                    if (i > 0)
                        ri[RULE_PEND] ++;
                    if (cache.size() == 1)
                        cache.setStatus(cache.getStatus(), currentTime);
                    if ((debug & DEBUG_UPDT) > 0)
                        new Event(Event.DEBUG, name + " " + ruleName +
                            " insert: " + key + " " + i + " " +
                            cache.size()).send();
                }
                else { // not exipired yet
                    int[] meta = cache.getMetaData(key);
                    if (meta != null && meta.length > 0)
                        meta[0] ++;
                    cache.touch(key, currentTime, currentTime - ttl);
                }

                oid = outLinkMap[BYPASS_OUT];
            }
            else try { // for escalation
                i =(tw != null) ? tw.check(currentTime,0L) : TimeWindows.NORMAL;
                msg = (TextEvent) escalator.escalate(i, currentTime, event);
                if (msg == null) // no escalation msg
                    i = BYPASS_OUT;
                else { // msg for escalation
                    if (ruleInfo[RULE_EXTRA] > 0) { // escalation first
                        int k;
                        oid = RESULT_OUT;
                        // use cid to track the flushed msg externally
                        k = flush(currentTime, cid, rid, msg, in, out[oid], oid,
                            buffer);
                        if (k <= 0)
                            new Event(Event.ERR, name + ": " + ruleName +
                                " failed to flush escalation msg to " +
                                oid + " so it got dropped").send();
                        else { // flush is done
                            long[] state = msgList.getMetaData(cid);
                            k = (int) state[MSG_BID];
                            // clean up msgList right away
                            msgList.remove(cid);
                            do { // wait for its delivery to complete
                                if (out[oid].collect(10*waitTime, k) >= 0)
                                    break;
                                mask = in.getGlobalMask();
                            } while ((mask & XQueue.KEEP_RUNNING) > 0 &&
                                (mask & XQueue.STANDBY) == 0);
                            if (ruleInfo[RULE_GID] > 0 && // for delay
                                (mask & XQueue.KEEP_RUNNING) > 0 &&
                                (mask & XQueue.STANDBY) == 0) try {
                                Thread.sleep(ruleInfo[RULE_GID]);
                            }
                            catch (Exception e) {
                            }
                        }
                    }
                    i = BYPASS_OUT;
                }
                oid = outLinkMap[i];
            }
            catch (Exception e) {
                String str = name + ": " + ruleName;
                Exception ex = null;
                if (e instanceof JMSException)
                    ex = ((JMSException) e).getLinkedException();
                if (ex != null)
                    str += " Linked exception: " + ex.toString() + "\n";
                i = FAILURE_OUT;
                oid = outLinkMap[i];
                new Event(Event.ERR, str + " failed to escalate msg: "+
                    Event.traceStack(e)).send();
            }
            catch (Error e) {
                String str = name + ": " + ruleName;
                new Event(Event.ERR, str + " failed to escalate msg: "+
                    e.toString()).send();
                if ((in.getGlobalMask() & XQueue.EXTERNAL_XA) > 0) try {
                    inMessage.acknowledge();
                }
                catch (Exception ex) {
                }
                catch (Error ex) {
                    in.remove(cid);
                    Event.flush(e);
                }
                in.remove(cid);
                Event.flush(e);
            }

            if ((debug & DEBUG_PROP) > 0)
                new Event(Event.DEBUG, name+" propagate: cid=" + cid +
                    " rid=" + rid + " oid=" + oid + " i=" + i).send();

            if (ruleInfo[RULE_DMASK] > 0) try { // display the message
                msgStr = null;
                if ((ruleInfo[RULE_DMASK] & dspBody) > 0)
                    msgStr = MessageUtils.processBody(inMessage, buffer);
                new Event(Event.INFO, name + ": " + ruleName+" checked msg " +
                    (count+1) +":"+ MessageUtils.display(inMessage, msgStr,
                    (int) ruleInfo[RULE_DMASK], propertyName)).send();
            }
            catch (Exception ex) {
                new Event(Event.WARNING, name + ": " + ruleName +
                    " failed to display msg: " + Event.traceStack(ex)).send();
            }

            i = passthru(currentTime, inMessage, in, rid, oid, cid, 0);
            if (i > 0)
                count ++;
            if (ruleInfo[RULE_EXTRA] == 0 && msg != null) {
                oid = RESULT_OUT;
                i = flush(currentTime, -1, rid, msg, in, out[oid], oid, buffer);
                if (i <= 0)
                    new Event(Event.ERR, name + ": " + ruleName +
                        " failed to flush escalation msg to " + oid +
                        " so it got dropped").send();
            }
            else if (ruleInfo[RULE_EXTRA] < 0 && msg != null) {
                if (msgList.existsID(cid)) // cache the escalation msg
                    o = msgList.set(cid, msg);
            }
            msg = null;
            feedback(in, -1L);
            sz = msgList.size();
            inMessage = null;
        }
    }

    /**
     * It displays and sets properties on the escalation message according to
     * its ruleset and puts it to the specified outlink. It returns the number 
     * of messages flushed. If cid >= 0, it will update msgList to track its
     * delivery externally. There is no rollback to cid in any case.
     */
    private int flush(long currentTime, int cid, int rid, TextEvent msg,
        XQueue in, XQueue out, int oid, byte[] buffer) {
        int i, dmask;
        long[] ruleInfo;
        String ruleName;
        MessageFilter filter;
        Map rule;
        String[] pn;

        if (msg == null) {
            new Event(Event.WARNING, name + " null msg in flush: cid=" + cid +
                " rid=" + rid + " oid=" + oid).send();
            return 0;
        }
        if ((debug & DEBUG_PROP) > 0)
            new Event(Event.DEBUG, name + " flush: cid=" + cid +
                " rid=" + rid + " oid=" + oid).send();

        ruleName = ruleList.getKey(rid);
        ruleInfo = ruleList.getMetaData(rid);
        rule = (Map) ruleList.get(rid);
        pn = (String[]) rule.get("PropertyName");
        filter = (MessageFilter) rule.get("Formatter");
        // retrieve displayMask from RULE_OPTION
        dmask = (int) ruleInfo[RULE_OPTION];

        if (dmask != 0) try { // display the message
            new Event(Event.INFO, name + ": " + ruleName +" escalated a msg: " +
                MessageUtils.display(msg, msg.getText(), dmask, pn)).send();
        }
        catch (Exception e) {
            new Event(Event.WARNING, name + ": " + ruleName +
                " failed to display msg: " + e.toString()).send();
        }

        if (filter != null && filter.hasFormatter()) try { // post format
            filter.format(msg, buffer);
        }
        catch (JMSException e) {
            new Event(Event.ERR, name + ": " + ruleName +
                " failed on post format: " + Event.traceStack(e)).send();
        }

        // flush the escalation msg without rolling back to cid
        i = passthru(currentTime, msg, in, rid, oid, cid, -1);
        if (i > 0) { // update escalation count on the rule
            ruleInfo[RULE_PEND] ++;
            ruleInfo[RULE_TIME] = currentTime;
        }

        return i;
    }

    /* checks escalators for session timeouts and resets their sessions */
    private int update(long currentTime, XQueue in, XQueue out, int oid,
        byte[] buffer) {
        StringBuffer strBuf = null;
        Browser browser;
        EventEscalation escalator;
        QuickCache cache;
        TextEvent msg;
        Map rule = null, map;
        int[] meta;
        long[] ri;
        long st, tm, mtime;
        int i, k, m, n, rid, count = 0;

        if ((debug | DEBUG_UPDT) > 0)
            strBuf = new StringBuffer();

        m = -1;
        count = 0;
        browser = ruleList.browser();
        while ((rid = browser.next()) >= 0) {
            rule = (Map) ruleList.get(rid);
            ri = ruleList.getMetaData(rid);
            if (TYPE_ACTION == (int) ri[RULE_PID]) {
                escalator = (EventEscalation) rule.get("Escalator");
                if (escalator == null || escalator.getSessionSize() <= 0)
                    continue;
                mtime = escalator.getSessionTime();
                st = ri[RULE_TTL];
                if (st > 0 && currentTime - mtime >= st) // session timed out
                    count += escalator.resetSession(currentTime);
                continue;
            }
            else if (TYPE_CACHE != (int) ri[RULE_PID])
                continue;
            cache = (QuickCache) rule.get("Cache");
            if (cache == null || cache.size() <= 0)
                continue;
            mtime = cache.getMTime();
            st = ri[RULE_TTL];
            if (st <= 0 || currentTime - mtime < st) // not timed out yet
                continue;
            count ++;
            if (m < 0)
                m = 0;
            mtime = currentTime;
            k = 0;
            n = 0;
            for (String key : cache.keySet()) {
                tm = cache.getTimestamp(key);
                if (currentTime - tm < st) { // not timed out yet
                    if (mtime > tm) // look for min
                        mtime = tm;
                    continue;
                }
                // expired so touch it first to retrieve the object
                meta = cache.getMetaData(key);
                i = (meta != null && meta.length > 0) ? meta[0] : -1;
                if (i == 0) { // skip the key already claimed
                    k ++;
                    continue;
                }
                // since it has expired, use earlier time to retrive state map 
                map = (Map) cache.get(key, tm);
                msg = new TextEvent(key + " timed out after " + i + " events");
                msg.setPriority((int) ri[RULE_EXTRA]);
                msg.removeAttribute("priority");
                msg.setAttribute("eventCount", String.valueOf(i));
                msg.setAttribute("lastTM", Event.dateFormat(new Date(tm)));
                msg.setAttribute("date",
                    Event.dateFormat(new Date(currentTime)));
                msg.setAttribute("status", "Normal");
                msg.setAttribute("EscalationKey", key);
                for (Object obj : map.keySet())
                    msg.setAttribute((String) obj, (String) map.get(obj));
                i = flush(currentTime, -1, rid, msg, in, out, oid, buffer);
                n ++;
                if (i <= 0)
                    new Event(Event.ERR, name + ": " + ruleList.getKey(rid) +
                        " failed to flush escalation msg to " + oid +
                        " for " + key).send();
            }
            if (n + k > 0) // clean up expired keys
                cache.disfragment(currentTime);
            i = cache.size();
            if (i > 0)
                cache.setStatus(cache.getStatus(), mtime);
            m += i;
            if ((debug | DEBUG_UPDT) > 0)
                strBuf.append("\n\t" + cache.getName() + ": " + n + " " +
                    k + " " + i);
        }
        if (m >= 0) { // update total pending on NOHIT
            ri = ruleList.getMetaData(0);
            ri[RULE_PEND] = m;
        }
        if ((debug | DEBUG_UPDT) > 0 && strBuf.length() > 0)
            new Event(Event.DEBUG, name + " Rule Flushed Reset Cached - " +
                m + strBuf.toString()).send();

        return count;
    }

    /**
     * It passes the message from the input XQueue over to an output XQueue and
     * returns 1 upon success or 0 otherwise. In case of cid < 0, the message
     * has nothing to do with the input XQueue. Nothing will be added to
     * msgList for tracking. No callbacks and no update on rule stats either.
     * If tid < 0, msg will not be put back to uplink in case of failure.
     * There is no update on rule stats and no callbacks either. In case of
     * cid >= 0 and tid < 0, it will add msg stats to msgList for external
     * tracking. But the user has to clean it up after the usage since it is
     * not collectible by feedback() without the callback.
     */
    protected int passthru(long currentTime, Message msg, XQueue in,
        int rid, int oid, int cid, int tid) {
        Object[] asset = null;
        XQueue out;
        long[] state, outInfo, ruleInfo = null;
        int id = -1, k, mid, mask, len, shift, outCapacity;
        asset = (Object[]) assetList.get(oid);
        if (asset == null) {
            if (cid >= 0) // incoming msg
                k = (tid >= 0) ? in.putback(cid) : -2;
            else
                k = -1;
            new Event(Event.ERR, name + ": asset is null on " +
                assetList.getKey(oid) + " of " + oid + " for " +
                rid + " with msg at " + cid + "/" + tid).send();
            try {
                Thread.sleep(500);
            }
            catch (Exception e) {
            }
            return 0;
        }
        out = (XQueue) asset[ASSET_XQ];
        outInfo = assetList.getMetaData(oid);
        len = (int) outInfo[OUT_LENGTH];
        switch (len) {
          case 0:
            shift = 0;
            for (k=0; k<1000; k++) { // reserve an empty cell
                id = out.reserve(-1L);
                if (id >= 0)
                    break;
                mask = in.getGlobalMask();
                if ((mask & XQueue.KEEP_RUNNING) == 0 ||
                    (mask & XQueue.STANDBY) > 0) // disabled or stopped
                    break;
                feedback(in, waitTime);
            }
            break;
          case 1:
            shift = (int) outInfo[OUT_OFFSET];
            for (k=0; k<1000; k++) { // reserve the empty cell
                id = out.reserve(-1L, shift);
                if (id >= 0)
                    break;
                mask = in.getGlobalMask();
                if ((mask & XQueue.KEEP_RUNNING) == 0 ||
                    (mask & XQueue.STANDBY) > 0) // disabled or stopped
                    break;
                feedback(in, waitTime);
            }
            break;
          default:
            shift = (int) outInfo[OUT_OFFSET];
            for (k=0; k<1000; k++) { // reserve an partitioned empty cell
                id = out.reserve(-1L, shift, len);
                if (id >= 0)
                    break;
                mask = in.getGlobalMask();
                if ((mask & XQueue.KEEP_RUNNING) == 0 ||
                    (mask & XQueue.STANDBY) > 0) // disabled or stopped
                    break;
                feedback(in, waitTime);
            }
            break;
        }
        outCapacity = (int) outInfo[OUT_CAPACITY];

        if (id >= 0 && id < outCapacity) { // id-th cell of out reserved
            String key = oid + "/" + id;
            mid = msgList.getID(key);
            if (mid < 0) { // id-th cell was empty before, add new entry to it
                if (cid >= 0) // incoming msg
                    mid = msgList.add(key, new long[]{cid, oid, id, rid,
                        tid, currentTime}, key, cid);
                else // generated msg
                    mid = -1;
            }
            else { // id-th cell has just been empty now, replace it
                Object o;
                cells.collect(-1L, mid);
                state = msgList.getMetaData(mid);
                o = msgList.remove(mid);
                in.remove(mid);
                outInfo[OUT_SIZE] --;
                outInfo[OUT_COUNT] ++;
                k = (int) state[MSG_RID];
                ruleInfo = ruleList.getMetaData(k);
                if (ruleInfo[RULE_EXTRA] < 0 && o instanceof TextEvent) {
                    byte[] buffer = new byte[4096];
                    mask = in.getGlobalMask();
                    if(ruleInfo[RULE_GID] > 0 && (mask & XQueue.STANDBY) == 0 &&
                        (mask & XQueue.KEEP_RUNNING) > 0) try { // for delay
                        Thread.sleep(ruleInfo[RULE_GID]);
                    }
                    catch (Exception e) {
                    }
                    asset = (Object[]) assetList.get(RESULT_OUT);
                    int i = flush(currentTime, -1, k, (TextEvent) o, in,
                        (XQueue) asset[ASSET_XQ], RESULT_OUT, buffer);
                    if (i <= 0)
                        new Event(Event.ERR, name + ": " + ruleList.getKey(k) +
                            " failed to flush escalation msg at " + mid).send();
                }
                ruleInfo[RULE_SIZE] --;
                ruleInfo[RULE_COUNT] ++;
                ruleInfo[RULE_TIME] = currentTime;
                if ((debug & DEBUG_FBAK) > 0)
                    new Event(Event.DEBUG, name+" passback: " + k + " " + mid +
                        ":" + state[MSG_CID] + " "+key+" "+ruleInfo[RULE_SIZE]+
                        " " + outInfo[OUT_SIZE] + " " + out.size() + ":" +
                        out.depth() + " " + msgList.size()).send();
                if (cid >= 0) // incoming msg or escalation first
                    mid = msgList.add(key, new long[] {cid, oid, id, rid,
                        tid, currentTime}, key, cid);
                else // generated msg
                    mid = -1;
            }
            if (cid >= 0 && mid < 0) { // failed to add state info to msgList
                out.cancel(id);
                k = (tid >= 0) ? in.putback(cid) : -2;
                new Event(Event.ERR, name + ": failed to add to MSGLIST at " +
                    mid + ":" + cid + "/" + tid + " with " + key + " for " +
                    ruleList.getKey(rid) + ": " + msgList.size() +","+k).send();
                return 0;
            }
            if (cid >= 0 && tid >= 0) { // incoming msg
                k = out.add(msg, id, cbw);
                ruleInfo = ruleList.getMetaData(rid);
                ruleInfo[RULE_SIZE] ++;
                ruleInfo[RULE_TIME] = currentTime;
                outInfo[OUT_SIZE] ++;
                if (outInfo[OUT_STATUS] == NODE_RUNNING)
                    outInfo[OUT_TIME] = currentTime;
            }
            else { // generated msg
                k = out.add(msg, id);
                outInfo[OUT_COUNT] ++;
                outInfo[OUT_TIME] = currentTime;
            }
            if ((debug & DEBUG_PASS) > 0) {
                if (cid < 0)
                    ruleInfo = ruleList.getMetaData(rid);
                new Event(Event.DEBUG, name+" passthru: " + rid + " " +
                    mid + ":" + cid + " " + key + " " + ruleInfo[RULE_SIZE] +
                    " " + outInfo[OUT_SIZE] + " " + out.size() + ":" +
                    out.depth() + " " + msgList.size()).send();
            }
            return 1;
        }
        else { // reservation failed
            if (cid >= 0) // incoming msg
                k = (tid >= 0) ? in.putback(cid) : -2;
            else // generated msg
                k = -1;
            ruleInfo = ruleList.getMetaData(rid);
            new Event(Event.WARNING, name + ": XQ is full on " +
                assetList.getKey(oid) + " of " + oid + " for " + rid +
                ": " + outInfo[OUT_QDEPTH] + "," + outInfo[OUT_SIZE] +
                ": " + out.size() + "," + out.depth() + " / " +
                ruleInfo[RULE_SIZE] + ": " + k).send();
            return 0;
        }
    }

    /**
     * It returns the number of done messages removed from the input XQueue.
     * If milliSec < 0, there is no wait and it tries to collect all cells.
     * Otherwise, it just tries to collect the first collectible cell.
     */
    protected int feedback(XQueue in, long milliSec) {
        Object o;
        Object[] asset;
        XQueue out;
        int mid, rid, oid, id, l = 0;
        long[] state, outInfo, ruleInfo;
        long t, wt = 0L;
        StringBuffer strBuf = null;
        if ((debug & DEBUG_FBAK) > 0)
            strBuf = new StringBuffer();

        t = System.currentTimeMillis();
        while ((mid = cells.collect(milliSec)) >= 0) {
            state = msgList.getMetaData(mid);
            oid = (int) state[MSG_OID];
            asset = (Object[]) assetList.get(oid);
            if (asset == null)
                continue;
            out = (XQueue) asset[ASSET_XQ];
            id = (int) state[MSG_BID];
            in.remove(mid);
            o = msgList.remove(mid);
            outInfo = assetList.getMetaData(oid);
            outInfo[OUT_SIZE] --;
            outInfo[OUT_COUNT] ++;
            if (outInfo[OUT_STATUS] == NODE_RUNNING)
                outInfo[OUT_TIME] = t;
            rid = (int) state[MSG_RID];
            ruleInfo = ruleList.getMetaData(rid);
            // check for escalation msg
            if (ruleInfo[RULE_EXTRA] < 0 && o instanceof TextEvent) {
                byte[] buffer = new byte[4096];
                if (ruleInfo[RULE_GID] > wt) { // for delay
                    int mask = in.getGlobalMask();
                    if ((mask & XQueue.KEEP_RUNNING) > 0 &&
                        (mask & XQueue.STANDBY) == 0) try {
                        Thread.sleep(ruleInfo[RULE_GID] - wt);
                    }
                    catch (Exception e) {
                    }
                    // reset wt for its maximum value
                    wt = ruleInfo[RULE_GID];
                }
                asset = (Object[]) assetList.get(RESULT_OUT);
                int i = flush(t, -1, rid, (TextEvent) o, in,
                    (XQueue) asset[ASSET_XQ], RESULT_OUT, buffer);
                if (i <= 0)
                    new Event(Event.ERR, name + ": " + ruleList.getKey(rid) +
                        " failed to flush escalation msg to " + RESULT_OUT +
                        " so it got dropped").send();
            }
            ruleInfo[RULE_SIZE] --;
            ruleInfo[RULE_COUNT] ++;
            ruleInfo[RULE_TIME] = t;
            if ((debug & DEBUG_FBAK) > 0)
                strBuf.append("\n\t" + rid + " " + mid + "/" + state[MSG_CID] +
                    " " + oid + ":" + id + " " + ruleInfo[RULE_SIZE] + " " +
                    outInfo[OUT_SIZE]+ " " + out.size() + "|" + out.depth() +
                    " " + msgList.size());
            l ++;
            if (milliSec >= 0) // only one collection a time
                break;
        }
        if (l > 0 && (debug & DEBUG_FBAK) > 0)
            new Event(Event.DEBUG, name + " feedback: RID MID/CID OID:ID " +
                "RS OS size|depth ms - " + l + " msgs fed back to " +
                in.getName() + " with " + in.size() + ":" + in.depth() +
                strBuf.toString()).send();

        return l;
    }

    public int updateParameters(Map props) {
        Object o;
        int i, n;

        n = super.updateParameters(props);
        if ((o = props.get("Heartbeat")) != null) {
            i = 1000 * Integer.parseInt((String) o);
            if (i >= 0 && i != heartbeat) {
                heartbeat = i;
                n++;
            }
        }

        return n;
    }

    /**
     * cleans up MetaData for all XQs and messages
     */
    public void resetMetaData(XQueue in, XQueue[] out) {
        Object[] asset;
        XQueue xq;
        Browser browser;
        long[] state;
        int[] list;
        int i, j, n, mid, oid, id, outCapacity;

        feedback(in, -1L);
        n = msgList.size();
        list = new int[n];
        n = msgList.queryIDs(list);
        for (i=0; i<n; i++) {
            mid = list[i];
            state = msgList.getMetaData(mid);
            oid = (int) state[MSG_OID];
            id = (int) state[MSG_BID];
            asset = (Object[]) assetList.get(oid);
            if (asset == null) {
                msgList.remove(mid);
                continue;
            }
            xq = (XQueue) asset[ASSET_XQ];
            if (xq != null) synchronized(xq) {
                if (xq.getCellStatus(id) == XQueue.CELL_OCCUPIED) {
                    xq.takeback(id);
                }
                else if (xq.getCellStatus(id) == XQueue.CELL_TAKEN) {
                    xq.remove(id);
                }
            }
            in.putback(mid);
            msgList.remove(mid);
        }

        browser = assetList.browser();
        while ((i = browser.next()) >= 0) {
            state = assetList.getMetaData(i);
            state[OUT_SIZE] = 0;
        }

        browser = ruleList.browser();
        while ((i = browser.next()) >= 0) {
            state = ruleList.getMetaData(i);
            state[RULE_SIZE] = 0;
        }
    }

    public void close() {
        Map rule;
        Browser browser;
        EventEscalation escalator;
        int rid;
        setStatus(NODE_CLOSED);
        cells.clear();
        msgList.clear();
        assetList.clear();
        browser = ruleList.browser();
        while((rid = browser.next()) >= 0) {
            rule = (Map) ruleList.get(rid);
            if (rule != null) {
                escalator = (EventEscalation) rule.get("Escalator");
                if (escalator != null)
                    escalator.clear();
                rule.clear();
            }
        }
        ruleList.clear();
        if (cfgList != null) {
            ConfigList cfg;
            browser = cfgList.browser();
            while((rid = browser.next()) >= 0) {
                cfg = (ConfigList) cfgList.get(rid);
                if (cfg != null)
                    cfg.close();
            }
            cfgList.clear();
        }
    }

    protected void finalize() {
        close();
    }
}
